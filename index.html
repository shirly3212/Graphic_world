<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mario 3D Portfolio World</title>
    <!-- Three.js library for 3D rendering -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* Basic reset for consistent styling */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Body styling for a clean, full-screen experience */
        body {
            font-family: 'Arial', sans-serif;
            overflow: hidden; /* Prevent scrolling */
            background: #5C94FC; /* Mario-sky blue */
            color: white;
        }

        /* Container for the 3D game canvas */
        #gameContainer {
            position: relative;
            width: 100vw; /* Full viewport width */
            height: 100vh; /* Full viewport height */
            display: flex; /* Use flexbox to center canvas if needed */
            justify-content: center;
            align-items: center;
        }

        /* Canvas styling to ensure it fills the container */
        canvas {
            display: block; /* Remove extra space below canvas */
        }

        /* Overlay for UI elements (controls, score, world info) */
        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allow clicks to pass through to canvas by default */
            z-index: 1000;
        }

        /* Styling for control information panel */
        .controls-info {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7); /* Semi-transparent background */
            padding: 15px;
            border-radius: 10px; /* Rounded corners */
            border: 3px solid #FFD700; /* Gold border */
            pointer-events: auto; /* Allow interaction with this panel */
        }

        .controls-info h3 {
            color: #FFD700; /* Gold heading */
            margin-bottom: 10px;
            font-size: 1.2rem;
        }

        .controls-info p {
            margin: 5px 0;
            font-size: 0.9rem;
        }

        /* Reset Camera Button */
        .reset-camera-btn {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(145deg, #007bff, #0056b3); /* Blue gradient */
            border: 3px solid #004085;
            color: white;
            padding: 10px 15px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            pointer-events: auto;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            z-index: 1001; /* Above other UI elements if needed */
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .reset-camera-btn:hover {
            background: linear-gradient(145deg, #0056b3, #007bff);
            transform: translateX(-50%) translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
        }

        /* New: World List Overlay */
        .world-list-overlay {
            position: absolute;
            top: 80px; /* Below the reset camera button */
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 10px;
            border: 2px solid #fff;
            text-align: center;
            color: white;
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .world-list-overlay h3 {
            margin: 0;
            color: #FFD700;
            font-size: 1.1rem;
        }

        .world-list-overlay .world-names {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            font-size: 0.95rem;
        }
        .world-list-overlay .world-names span {
            padding: 2px 5px;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
        }

        /* Styling for score panel */
        .score-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 3px solid #FFD700;
            text-align: center;
            pointer-events: auto;
        }

        .score-panel h3 {
            color: #FFD700;
            margin-bottom: 10px;
        }

        /* Styling for world information panel */
        .world-info {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%); /* Center horizontally */
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 15px;
            border: 3px solid #FF6B6B; /* Red border */
            text-align: center;
            max-width: 400px;
            pointer-events: auto;
            display: none; /* Hidden by default */
        }

        /* Class to show the world info panel with animation */
        .world-info.active {
            display: block;
            animation: worldInfoPop 0.5s ease-out forwards; /* Pop animation */
        }

        /* Keyframe animation for the world info panel */
        @keyframes worldInfoPop {
            0% { transform: translateX(-50%) scale(0.8) translateY(20px); opacity: 0; }
            100% { transform: translateX(-50%) scale(1) translateY(0px); opacity: 1; }
        }

        .world-info h2 {
            color: #FFD700;
            margin-bottom: 10px;
            font-size: 1.5rem;
        }

        .world-info p {
            line-height: 1.6;
            margin-bottom: 15px;
        }

        /* Styling for the "Enter World" button */
        .enter-btn {
            background: linear-gradient(145deg, #FF6B6B, #FF3333); /* Red gradient */
            border: 3px solid #CC0000;
            color: white;
            padding: 10px 20px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease; /* Smooth transition for hover effects */
            pointer-events: auto;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3); /* Subtle shadow */
        }

        .enter-btn:hover {
            background: linear-gradient(145deg, #FF3333, #FF6B6B);
            transform: translateY(-2px); /* Slight lift on hover */
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
        }

        /* Loading screen styling */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #5C94FC, #87CEEB); /* Blue sky gradient */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            transition: opacity 1s ease-out; /* Fade out effect */
        }

        .loading-screen.hidden {
            opacity: 0;
            pointer-events: none; /* No interaction when hidden */
        }

        /* Mario logo styling on loading screen */
        .mario-logo {
            font-size: 4rem;
            font-weight: bold;
            color: #FFD700; /* Gold color */
            text-shadow: 3px 3px 0px #FF6B6B; /* Red shadow for retro look */
            margin-bottom: 20px;
            animation: logoFloat 2s infinite ease-in-out; /* Floating animation */
        }

        /* Keyframe animation for the floating logo */
        @keyframes logoFloat {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }

        /* Loading bar styling */
        .loading-bar {
            width: 300px;
            height: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid #FFD700;
        }

        .loading-progress {
            height: 100%;
            background: linear-gradient(90deg, #FF6B6B, #FFD700); /* Red to gold gradient */
            width: 0%; /* Starts at 0% and expands */
            transition: width 0.3s ease;
            border-radius: 8px;
        }

        /* Mobile controls styling */
        .mobile-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: none; /* Hidden by default on larger screens */
            flex-direction: column;
            gap: 10px;
            pointer-events: auto;
        }

        .mobile-btn {
            width: 60px;
            height: 60px;
            background: rgba(0, 0, 0, 0.7);
            border: 3px solid #FFD700;
            border-radius: 50%; /* Circular buttons */
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            color: white;
            cursor: pointer;
            user-select: none; /* Prevent text selection */
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
            transition: transform 0.1s ease;
        }

        .mobile-btn:active {
            transform: scale(0.95); /* Visual feedback on press */
        }

        .mobile-dpad {
            display: grid;
            grid-template-columns: repeat(3, 60px); /* 3 columns for d-pad layout */
            gap: 5px;
            pointer-events: auto;
        }

        .mobile-dpad .mobile-btn {
            border-radius: 10px; /* Square buttons for d-pad */
        }

        /* Media query for mobile responsiveness */
        @media (max-width: 768px) {
            .mobile-controls {
                display: flex; /* Show mobile controls on small screens */
            }
            
            .controls-info {
                display: none; /* Hide desktop controls info on small screens */
            }
            .reset-camera-btn {
                top: auto;
                bottom: 90px; /* Adjust position for mobile, above mobile controls */
                left: 20px;
                transform: none; /* Remove translateX centering */
                right: auto;
            }
            .world-list-overlay {
                top: 70px; /* Adjust position for mobile */
                width: 90%;
            }
        }
    </style>
</head>
<body>
    <!-- Loading screen visible on page load -->
    <div class="loading-screen" id="loadingScreen">
        <div class="mario-logo">ğŸ„ MARIO PORTFOLIO WORLD ğŸ„</div>
        <div class="loading-bar">
            <div class="loading-progress" id="loadingProgress"></div>
        </div>
        <p style="margin-top: 20px; font-size: 1.2rem;">Loading your adventure...</p>
    </div>

    <!-- Main game container -->
    <div id="gameContainer">
        <!-- UI overlay for game information and controls -->
        <div class="ui-overlay">
            <div class="controls-info">
                <h3>ğŸ® ×‘×§×¨×•×ª ××¨×™×•</h3>
                <p><strong>WASD / ×—×¦×™×:</strong> ×”×–×– ××ª ××¨×™×•</p>
                <p><strong>×¨×•×•×—:</strong> ×§×¤×™×¦×”</p>
                <p><strong>×× ×˜×¨:</strong> ×›× ×™×¡×” ×œ×¢×•×œ×</p>
                <p><strong>×¢×›×‘×¨:</strong> ×”×¡×ª×›×œ ××¡×‘×™×‘</p>
                <p><strong>Shift:</strong> ×¨×•×¥ ××”×¨</p>
            </div>

            <!-- Reset Camera Button -->
            <button class="reset-camera-btn" onclick="resetCamera()">
                <span style="font-size: 1.2em;">ğŸ“¸</span> ××™×¤×•×¡ ××¦×œ××”
            </button>

            <!-- New: World List Overlay -->
            <div class="world-list-overlay" id="worldListOverlay">
                <h3>ğŸŒ ×¢×•×œ××•×ª ×œ×—×§×•×¨:</h3>
                <div class="world-names" id="worldNames">
                    <!-- World names will be injected here by JavaScript -->
                </div>
            </div>

            <div class="score-panel">
                <h3>ğŸ† ×¡×˜×˜×™×¡×˜×™×§×•×ª</h3>
                <p><strong>××˜×‘×¢×•×ª:</strong> <span id="coinCount">0</span></p>
                <p><strong>××™×§×•×:</strong> <span id="currentWorld">×”××‘</span></p>
                <p><strong>×—×™×™×:</strong> <span id="lives">3</span></p>
            </div>

            <div class="world-info" id="worldInfo">
                <h2 id="worldTitle">×‘×¨×•×š ×”×‘×!</h2>
                <p id="worldDescription">×”×ª×§×¨×‘ ×œ××—×ª ×”×¤×œ×˜×¤×•×¨××•×ª ××• ×œ××‘× ×™ ×”×¤×˜×¨×™×™×” ×›×“×™ ×œ×¨××•×ª ×¤×¨×˜×™× ×•×œ×”×™×›× ×¡ ×œ×¢×•×œ×!</p>
                <button class="enter-btn" onclick="enterWorld()" id="enterBtn" style="display: none;">
                    ğŸšª ×›× ×™×¡×” ×œ×¢×•×œ×
                </button>
            </div>

            <!-- Mobile controls (hidden on desktop) -->
            <div class="mobile-controls">
                <div class="mobile-dpad">
                    <div></div>
                    <div class="mobile-btn" data-key="w">â†‘</div>
                    <div></div>
                    <div class="mobile-btn" data-key="a">â†</div>
                    <div class="mobile-btn" data-key="s">â†“</div>
                    <div class="mobile-btn" data-key="d">â†’</div>
                </div>
                <div class="mobile-btn" data-key=" ">ğŸ¦˜</div> <!-- Jump button -->
            </div>
        </div>
    </div>

    <script>
        // --- Global Game Variables ---
        let scene, camera, renderer, mario;
        // Object to track pressed keys
        let keys = {};
        // Mouse coordinates for camera rotation
        let mouseX = 0, mouseY = 0;
        // Mario's physics properties
        let marioVelocity = { x: 0, y: 0, z: 0 };
        let isGrounded = false;
        // Current world zone Mario is near
        let currentWorldZone = null;
        // Game stats
        let coins = 0;
        let lives = 3;
        // Arrays to hold Three.js objects for interaction and environment
        let interactiveZones = []; // Holds both platforms and mushroom buildings for proximity checks
        let collectibles = [];
        let trees = [];
        let smallMushrooms = []; // Corrected name for clarity for decorative mushrooms
        let animatedClouds = []; // To store clouds that will move

        // Clock for delta time calculations (smooth animations)
        let clock = new THREE.Clock();

        // --- World Data Configuration ---
        const worlds = {
            web: {
                title: "ğŸ–¥ï¸ ×¢×•×œ× ×¤×™×ª×•×— ×•×•×‘",
                description: "×—×§×•×¨ ××ª ×ª×—×•× ×”-HTML, CSS, JavaScript ×•×¤×¨×•×™×§×˜×™× ××•×“×¨× ×™×™×. ×‘× ×” ×—×•×•×™×•×ª ×•×•×‘ ××“×”×™××•×ª!",
                color: 0xff6b6b, // Red
                position: { x: -15, z: -15 }, // Platform position
                mushroomPosition: { x: -30, z: -35 }, // New mushroom building position
                link: "https://example.com/web-portfolio" // Example link
            },
            animation: {
                title: "ğŸ¬ ×¢×•×œ× ×× ×™××¦×™×”", 
                description: "×¦×œ×•×œ ×œ×ª×•×š ×’×¨×¤×™×§×ª ×ª× ×•×¢×”, ×× ×™××¦×™×” ×ª×œ×ª-×××“×™×ª ×•××¤×§×˜×™× ×•×™×–×•××œ×™×™×. ×”×’×© ××ª ×”×¨×¢×™×•× ×•×ª ×©×œ×š ×œ×—×™×™×!",
                color: 0x4ecdc4, // Cyan
                position: { x: 15, z: -15 },
                mushroomPosition: { x: 30, z: -35 },
                link: "https://example.com/animation-portfolio"
            },
            design: {
                title: "ğŸ¨ ×¢×•×œ× ×¢×™×¦×•×‘ ×’×¨×¤×™",
                description: "×¦×•×¨ ×–×”×•×™×•×ª ×—×–×•×ª×™×•×ª ××“×”×™××•×ª, ×œ×•×’×•××™× ×•××™×ª×•×’. ×‘×˜× ×™×¦×™×¨×ª×™×•×ª ×‘×××¦×¢×•×ª ×¢×™×¦×•×‘!",
                color: 0xffe66d, // Yellow
                position: { x: -15, z: 15 },
                mushroomPosition: { x: -30, z: 35 },
                link: "https://example.com/design-portfolio"
            },
            ai: {
                title: "ğŸ¤– ×¢×•×œ× AI",
                description: "×”×™×›× ×¡ ×œ×¢×ª×™×“ ×¢× ×œ××™×“×ª ××›×•× ×”, ×¨×©×ª×•×ª ×¢×¦×‘×™×•×ª ×•××™× ×˜×œ×™×’× ×¦×™×” ××œ××›×•×ª×™×ª!",
                color: 0xa8e6cf, // Light Green
                position: { x: 15, z: 15 },
                mushroomPosition: { x: 30, z: 35 },
                link: "https://example.com/ai-portfolio"
            }
        };

        // --- Game Initialization ---
        function init() {
            // Set up the scene, background, and fog
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x5c94fc); // Sky blue
            scene.fog = new THREE.Fog(0x5c94fc, 50, 200); // Atmospheric fog

            // Set up the camera (PerspectiveCamera for 3D realism)
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 8, 12); // Initial camera position

            // Set up the WebGL renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight); // Set renderer size to full window
            renderer.shadowMap.enabled = true; // Enable shadow mapping
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Softer shadows
            document.getElementById('gameContainer').appendChild(renderer.domElement); // Add canvas to HTML

            // Call functions to set up game elements
            setupLighting();
            createWorld();
            createMario();
            createWorldPlatforms(); // Creates platforms and adds to interactiveZones
            createMushroomBuildings(); // Creates mushroom buildings and adds to interactiveZones
            createCollectibles();
            createTrees(15); // Add 15 trees
            createSmallMushrooms(10); // Add 10 small decorative mushrooms
            
            // Set up event listeners for user input
            setupEventListeners();
            
            // Populate the new world list overlay
            populateWorldListOverlay();

            // Start the main game animation loop
            animate();

            // Hide the loading screen after a delay
            setTimeout(() => {
                document.getElementById('loadingScreen').classList.add('hidden');
                updateLoadingProgress(100); // Ensure progress bar is full
            }, 2000); // 2-second loading animation
        }

        // --- UI Update Functions ---
        function updateLoadingProgress(progress) {
            document.getElementById('loadingProgress').style.width = progress + '%';
        }

        function updateCoinCount(amount) {
            coins += amount;
            document.getElementById('coinCount').innerText = coins;
        }

        function updateLives(amount) {
            lives += amount;
            document.getElementById('lives').innerText = lives;
            if (lives <= 0) {
                console.log("Game Over! Mario ran out of lives.");
                // Implement game over logic (e.g., reset, show message)
            }
        }

        function updateCurrentWorldUI(worldName) {
            document.getElementById('currentWorld').innerText = worldName;
        }

        // New function to populate the world list overlay
        function populateWorldListOverlay() {
            const worldNamesContainer = document.getElementById('worldNames');
            worldNamesContainer.innerHTML = ''; // Clear existing content

            Object.keys(worlds).forEach(worldKey => {
                const worldData = worlds[worldKey];
                const span = document.createElement('span');
                // Display the primary name of the world (e.g., "Web", "Animation")
                span.innerText = worldData.title.split(' ')[0]; 
                worldNamesContainer.appendChild(span);
            });
        }

        // --- Lighting Setup ---
        function setupLighting() {
            // Ambient light for general scene illumination
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            // Hemisphere light for more natural outdoor lighting (sky color, ground color)
            const hemiLight = new THREE.HemisphereLight(0xadd8e6, 0x7cfc00, 0.6); // Sky blue to grass green
            scene.add(hemiLight);

            // Directional light to simulate the sun (for shadows)
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 50, 50); // Position of the sun
            directionalLight.castShadow = true; // Enable shadow casting
            // Configure shadow map resolution and camera
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 500;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            scene.add(directionalLight);

            // Additional point lights for visual flair
            const pointLight1 = new THREE.PointLight(0xffd700, 1, 30); // Gold light
            pointLight1.position.set(-20, 10, -20);
            scene.add(pointLight1);

            const pointLight2 = new THREE.PointLight(0xff6b6b, 1, 30); // Red light
            pointLight2.position.set(20, 10, 20);
            scene.add(pointLight2);
        }

        // --- World Creation ---
        function createWorld() {
            // Ground Plane
            const groundGeometry = new THREE.PlaneGeometry(100, 100); // Large flat plane
            const groundMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x90ee90, // Light green
                map: createGrassTexture() // Custom grass texture
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2; // Rotate to be horizontal
            ground.receiveShadow = true; // Ground receives shadows
            scene.add(ground);

            // Sky Dome
            const skyGeometry = new THREE.SphereGeometry(200, 32, 16); // Large sphere
            const skyMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x87ceeb, // Sky blue
                side: THREE.BackSide // Render inside the sphere
            });
            const sky = new THREE.Mesh(skyGeometry, skyMaterial);
            scene.add(sky);

            // Add decorative Mario-style elements
            createPipes();
            createClouds(); // Now creates animated clouds
        }

        // Function to create a simple procedural grass texture
        function createGrassTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128; // Increased resolution
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            // Base grass color
            ctx.fillStyle = '#7CFC00'; // Brighter green
            ctx.fillRect(0, 0, 128, 128);
            
            // Add some darker green specks for texture
            for (let i = 0; i < 300; i++) { // More specks
                ctx.fillStyle = `hsl(${100 + Math.random() * 30}, 60%, ${30 + Math.random() * 15}%)`;
                ctx.fillRect(Math.random() * 128, Math.random() * 128, 2, 2);
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping; // Repeat texture
            texture.repeat.set(10, 10); // How many times to repeat over the ground
            texture.magFilter = THREE.NearestFilter; // Pixelated look
            return texture;
        }

        // Create multiple pipes at various positions
        function createPipes() {
            const pipePositions = [
                { x: -30, z: -30 },
                { x: 30, z: -30 },
                { x: -30, z: 30 },
                { x: 30, z: 30 },
                { x: 0, z: -35 },
                { x: -35, z: 0 },
                { x: 35, z: 0 },
                { x: 0, z: 35 }
            ];

            pipePositions.forEach(pos => {
                const pipe = createPipe();
                pipe.position.set(pos.x, 0, pos.z); // Pipes start at y=0
                scene.add(pipe);
            });
        }

        // Function to create a single Mario-style pipe
        function createPipe() {
            const pipeGroup = new THREE.Group();
            
            // Main pipe body (cylinder)
            const bodyGeometry = new THREE.CylinderGeometry(1.5, 1.5, 6, 32); // Radius, height, segments
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x228b22 }); // Dark green
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 3; // Half its height to sit on the ground
            body.castShadow = true;
            pipeGroup.add(body);
            
            // Pipe top (wider cylinder)
            const topGeometry = new THREE.CylinderGeometry(2, 2, 1, 32);
            const topMaterial = new THREE.MeshLambertMaterial({ color: 0x32cd32 }); // Lighter green
            const top = new THREE.Mesh(topGeometry, topMaterial);
            top.position.y = 6.5; // Sits on top of the body
            top.castShadow = true;
            pipeGroup.add(top);
            
            return pipeGroup;
        }

        // Function to create a simple procedural cloud texture
        function createCloudTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.fillRect(0, 0, 64, 64);
            ctx.filter = 'blur(4px)'; // Apply blur for softness

            ctx.beginPath();
            ctx.arc(20, 20, 15, 0, Math.PI * 2);
            ctx.arc(40, 25, 18, 0, Math.PI * 2);
            ctx.arc(30, 40, 16, 0, Math.PI * 2);
            ctx.arc(50, 35, 14, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)'; // Slightly darker inside
            ctx.fill();

            return new THREE.CanvasTexture(canvas);
        }

        // Create multiple clouds scattered around the sky
        function createClouds() {
            const cloudMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xffffff, 
                transparent: true, 
                opacity: 0.8,
                map: createCloudTexture() // Apply new cloud texture
            });

            for (let i = 0; i < 20; i++) { // More clouds for better movement effect
                const cloudGroup = new THREE.Group();
                
                // Create multiple spheres to form a fluffy cloud shape
                for (let j = 0; j < 6; j++) {
                    const sphereGeometry = new THREE.SphereGeometry(1 + Math.random() * 2.5, 16, 16);
                    const sphere = new THREE.Mesh(sphereGeometry, cloudMaterial);
                    sphere.position.set(
                        (Math.random() - 0.5) * 8,
                        (Math.random() - 0.5) * 3,
                        (Math.random() - 0.5) * 8
                    );
                    sphere.castShadow = true;
                    cloudGroup.add(sphere);
                }
                
                cloudGroup.position.set(
                    (Math.random() - 0.5) * 200, // Wider spawn range
                    20 + Math.random() * 15,     // Random Y (height)
                    (Math.random() - 0.5) * 200  // Random Z within a larger range
                );
                cloudGroup.userData.speed = (Math.random() * 0.5 + 0.1) * (Math.random() > 0.5 ? 1 : -1); // Random speed and direction
                scene.add(cloudGroup);
                animatedClouds.push(cloudGroup); // Add to animatedClouds array
            }
        }

        // --- Mario Character Creation ---
        function createMario() {
            const marioGroup = new THREE.Group(); // Group all Mario parts together
            
            // Body (red cube)
            const bodyGeometry = new THREE.BoxGeometry(1, 1.5, 0.8);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 }); // Red
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.75; // Position above the feet
            body.castShadow = true;
            marioGroup.add(body);
            
            // Head (peach sphere) - Increased segments for smoother look
            const headGeometry = new THREE.SphereGeometry(0.6, 64, 32); // Increased segments
            const headMaterial = new THREE.MeshLambertMaterial({ color: 0xffdbac }); // Peach skin tone
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 2; // Position above the body
            head.castShadow = true;
            marioGroup.add(head);
            
            // Hat (red cylinder) - Increased segments for smoother look
            const hatGeometry = new THREE.CylinderGeometry(0.7, 0.7, 0.3, 64); // Increased segments
            const hatMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 });
            const hat = new THREE.Mesh(hatGeometry, hatMaterial);
            hat.position.y = 2.4; // Sits on top of the head
            hat.castShadow = true;
            marioGroup.add(hat);
            
            // Legs (blue cubes)
            const legGeometry = new THREE.BoxGeometry(0.3, 0.8, 0.3);
            const legMaterial = new THREE.MeshLambertMaterial({ color: 0x0000ff }); // Blue
            
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.25, -0.4, 0); // Offset to the left
            leftLeg.castShadow = true;
            marioGroup.add(leftLeg);
            
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.25, -0.4, 0); // Offset to the right
            rightLeg.castShadow = true;
            marioGroup.add(rightLeg);
            
            marioGroup.position.set(0, 2, 0); // Initial Mario position
            mario = marioGroup; // Assign the created group to the global mario variable
            scene.add(mario); // Add Mario to the scene
        }

        // --- World Platform Creation ---
        function createWorldPlatforms() {
            Object.keys(worlds).forEach(worldKey => {
                const worldData = worlds[worldKey];
                const platform = createPlatform(worldData.color, worldKey);
                platform.position.set(worldData.position.x, 2, worldData.position.z); // Position platforms slightly above ground
                scene.add(platform);
                interactiveZones.push({ // Add to interactiveZones
                    mesh: platform,
                    worldKey: worldKey,
                    position: platform.position // Use platform's actual position
                });
            });
        }

        // Function to create a single world platform with a question block
        function createPlatform(color, worldKey) {
            const platformGroup = new THREE.Group();
            
            // Main platform (cylinder)
            const platformGeometry = new THREE.CylinderGeometry(4, 4, 1, 32);
            const platformMaterial = new THREE.MeshLambertMaterial({ color: color });
            const platform = new THREE.Mesh(platformGeometry, platformMaterial);
            platform.castShadow = true;
            platform.receiveShadow = true;
            platformGroup.add(platform);
            
            // Question block on top
            const blockGeometry = new THREE.BoxGeometry(1, 1, 1);
            const blockMaterial = new THREE.MeshLambertMaterial({ color: 0xffd700 }); // Gold
            const block = new THREE.Mesh(blockGeometry, blockMaterial);
            block.position.y = 1; // Position above the platform
            block.castShadow = true;
            
            // Store data for animation and interaction
            block.userData = { 
                originalY: block.position.y, 
                worldKey: worldKey,
                isQuestionBlock: true,
                animationOffset: 0 // For bobbing animation
            };
            
            platformGroup.add(block);
            platformGroup.userData = { worldKey: worldKey, type: 'platform' }; // Store world key and type on the group for easy access
            
            return platformGroup;
        }

        // --- Collectibles Creation ---
        function createCollectibles() {
            // Create coins around the world
            for (let i = 0; i < 20; i++) {
                const coin = createCoin();
                coin.position.set(
                    (Math.random() - 0.5) * 60, // Random X
                    1 + Math.random() * 3,      // Random Y (slightly floating)
                    (Math.random() - 0.5) * 60  // Random Z
                );
                scene.add(coin);
                collectibles.push(coin);
            }
            
            // Create power-ups
            for (let i = 0; i < 5; i++) {
                const powerUp = createPowerUp();
                powerUp.position.set(
                    (Math.random() - 0.5) * 40,
                    1,
                    (Math.random() - 0.5) * 40
                );
                scene.add(powerUp);
                collectibles.push(powerUp);
            }
        }

        // Function to create a single coin
        function createCoin() {
            const coinGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.1, 32); // Flat cylinder
            const coinMaterial = new THREE.MeshPhongMaterial({ color: 0xffd700, specular: 0xffff00, shininess: 100 }); // Gold with shine
            const coin = new THREE.Mesh(coinGeometry, coinMaterial);
            coin.userData = { 
                type: 'coin', 
                value: 1, // Value for coin count
                originalY: coin.position.y,
                rotationSpeed: 0.05 // For spinning animation
            };
            coin.castShadow = true;
            return coin;
        }

        // Function to create a single power-up (e.g., mushroom)
        function createPowerUp() {
            const powerUpGeometry = new THREE.BoxGeometry(1, 1, 1);
            const powerUpMaterial = new THREE.MeshLambertMaterial({ color: 0xff6b6b }); // Red
            const powerUp = new THREE.Mesh(powerUpGeometry, powerUpMaterial);
            powerUp.userData = { 
                type: 'powerup', 
                value: 1, // Value for lives count
                originalY: powerUp.position.y,
                rotationSpeed: 0.02
            };
            powerUp.castShadow = true;
            return powerUp;
        }

        // --- New: Mushroom Buildings ---
        // Function to create a large mushroom building with a door
        function createMushroomBuilding(color, worldKey) {
            const mushroomHouseGroup = new THREE.Group();

            // Stem - large cylinder
            const stemGeometry = new THREE.CylinderGeometry(3, 3.5, 8, 32);
            const stemMaterial = new THREE.MeshLambertMaterial({ color: 0xfff0c6 }); // Creamy white/light beige
            const stem = new THREE.Mesh(stemGeometry, stemMaterial);
            stem.position.y = 4; // Half its height
            stem.castShadow = true;
            stem.receiveShadow = true;
            mushroomHouseGroup.add(stem);

            // Cap - large half-sphere for the roof
            const capGeometry = new THREE.SphereGeometry(5, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2); // Half sphere
            const capMaterial = new THREE.MeshLambertMaterial({ color: color }); // World-specific color
            const cap = new THREE.Mesh(capGeometry, capMaterial);
            cap.position.y = 8; // On top of the stem
            cap.rotation.x = Math.PI; // Flip to be convex upwards
            cap.castShadow = true;
            mushroomHouseGroup.add(cap);

            // Door - simple box geometry
            const doorGeometry = new THREE.BoxGeometry(2, 4, 0.2);
            const doorMaterial = new THREE.MeshLambertMaterial({ color: 0x8b4513 }); // Brown door
            const door = new THREE.Mesh(doorGeometry, doorMaterial);
            door.position.set(0, 2.5, 3.5); // Position on the stem, slightly out
            door.castShadow = true;
            mushroomHouseGroup.add(door);

            // Add some simple windows
            const windowMaterial = new THREE.MeshLambertMaterial({ color: 0xadd8e6 }); // Light blue for glass
            const windowGeometry = new THREE.BoxGeometry(0.8, 1.5, 0.1);

            const window1 = new THREE.Mesh(windowGeometry, windowMaterial);
            window1.position.set(2.5, 5, 2.5);
            window1.rotation.y = Math.PI / 4;
            window1.castShadow = true;
            mushroomHouseGroup.add(window1);

            const window2 = new THREE.Mesh(windowGeometry, windowMaterial);
            window2.position.set(-2.5, 5, 2.5);
            window2.rotation.y = -Math.PI / 4;
            window2.castShadow = true;
            mushroomHouseGroup.add(window2);

            mushroomHouseGroup.userData = { worldKey: worldKey, type: 'mushroomBuilding' };
            return mushroomHouseGroup;
        }

        // Function to create all mushroom buildings and add them to interactive zones
        function createMushroomBuildings() {
            Object.keys(worlds).forEach(worldKey => {
                const worldData = worlds[worldKey];
                const mushroomBuilding = createMushroomBuilding(worldData.color, worldKey);
                // Adjusted y position to ensure it's not cut off by the ground
                mushroomBuilding.position.set(worldData.mushroomPosition.x, 0.5, worldData.mushroomPosition.z); 
                scene.add(mushroomBuilding);
                interactiveZones.push({ // Add to interactiveZones
                    mesh: mushroomBuilding,
                    worldKey: worldKey,
                    position: mushroomBuilding.position // Use mushroom's actual position
                });
            });
        }


        // --- Environmental Objects ---
        function createTrees(count) {
            for (let i = 0; i < count; i++) {
                const tree = createTree();
                tree.position.set(
                    (Math.random() - 0.5) * 90, // Wider spread
                    0,
                    (Math.random() - 0.5) * 90
                );
                scene.add(tree);
                trees.push(tree);
            }
        }

        function createTree() {
            const treeGroup = new THREE.Group();

            // Trunk
            const trunkGeometry = new THREE.BoxGeometry(1, 5, 1);
            const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8b4513 }); // Brown
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 2.5; // Half its height
            trunk.castShadow = true;
            trunk.receiveShadow = true;
            treeGroup.add(trunk);

            // Leaves (multiple spheres or cubes)
            const leafMaterial = new THREE.MeshLambertMaterial({ color: 0x228b22 }); // Forest Green

            const sphere1 = new THREE.Mesh(new THREE.SphereGeometry(2, 8, 8), leafMaterial);
            sphere1.position.set(0, 5, 0);
            sphere1.castShadow = true;
            treeGroup.add(sphere1);

            const sphere2 = new THREE.Mesh(new THREE.SphereGeometry(1.5, 8, 8), leafMaterial);
            sphere2.position.set(-1, 5.5, -0.5);
            sphere2.castShadow = true;
            treeGroup.add(sphere2);

            const sphere3 = new THREE.Mesh(new THREE.SphereGeometry(1.8, 8, 8), leafMaterial);
            sphere3.position.set(1, 5.2, 0.5);
            sphere3.castShadow = true;
            treeGroup.add(sphere3);
            
            // Randomize size slightly
            const scale = 0.8 + Math.random() * 0.4;
            treeGroup.scale.set(scale, scale, scale);

            return treeGroup;
        }

        // Renamed function for clarity
        function createSmallMushrooms(count) { 
            for (let i = 0; i < count; i++) {
                const mushroom = createSmallMushroom(); // Call the specific small mushroom function
                mushroom.position.set(
                    (Math.random() - 0.5) * 70, // Spread
                    0,
                    (Math.random() - 0.5) * 70
                );
                scene.add(mushroom);
                smallMushrooms.push(mushroom); // Add to the dedicated array
            }
        }

        // Renamed function for clarity
        function createSmallMushroom() { 
            const mushroomGroup = new THREE.Group();

            // Stem (white cylinder)
            const stemGeometry = new THREE.CylinderGeometry(0.5, 0.5, 1.5, 16);
            const stemMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff }); // White
            const stem = new THREE.Mesh(stemGeometry, stemMaterial);
            stem.position.y = 0.75;
            stem.castShadow = true;
            mushroomGroup.add(stem);

            // Cap (red sphere half)
            const capGeometry = new THREE.SphereGeometry(1, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2); // Half sphere
            const capMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 }); // Red
            const cap = new THREE.Mesh(capGeometry, capMaterial);
            cap.position.y = 1.5;
            cap.rotation.x = Math.PI; // Flip to be convex upwards
            cap.castShadow = true;
            mushroomGroup.add(cap);

            // White dots on cap
            const dotMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff });
            const dotRadius = 0.2;
            const dotPositions = [
                { x: 0.5, y: 1.8, z: 0 },
                { x: -0.5, y: 1.8, z: 0 },
                { x: 0, y: 1.8, z: 0.5 },
                { x: 0, y: 1.8, z: -0.5 }
            ];
            dotPositions.forEach(pos => {
                const dot = new THREE.Mesh(new THREE.SphereGeometry(dotRadius, 8, 8), dotMaterial);
                dot.position.set(pos.x, pos.y, pos.z);
                dot.castShadow = true;
                mushroomGroup.add(dot);
            });
            
            // Randomize size slightly
            const scale = 0.8 + Math.random() * 0.4;
            mushroomGroup.scale.set(scale, scale, scale);

            return mushroomGroup;
        }


        // --- Event Listeners ---
        function setupEventListeners() {
            // Keyboard events for movement and actions
            document.addEventListener('keydown', (event) => {
                keys[event.code] = true;
                if (event.code === 'Space') {
                    event.preventDefault(); // Prevent page scrolling
                    jump();
                }
                if (event.code === 'Enter' && currentWorldZone) {
                    enterWorld(currentWorldZone);
                }
            });

            document.addEventListener('keyup', (event) => {
                keys[event.code] = false;
            });

            // Mouse events for camera rotation (look around)
            document.addEventListener('mousemove', (event) => {
                // Normalize mouse coordinates to -1 to +1 range
                mouseX = (event.clientX / window.innerWidth) * 2 - 1;
                mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
            });

            // Touch events for mobile controls
            document.querySelectorAll('.mobile-btn').forEach(btn => {
                btn.addEventListener('touchstart', (e) => {
                    e.preventDefault(); // Prevent default touch behavior
                    const key = btn.dataset.key;
                    if (key === ' ') {
                        jump();
                    } else {
                        // Map mobile button data-key to keyboard event codes
                        keys['Key' + key.toUpperCase()] = true;
                    }
                });

                btn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    const key = btn.dataset.key;
                    if (key !== ' ') {
                        keys['Key' + key.toUpperCase()] = false;
                    }
                });
            });

            // Window resize event to update camera and renderer
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        // --- Player Actions ---
        function jump() {
            if (isGrounded) {
                marioVelocity.y = 12; // Apply upward velocity for jump
                isGrounded = false;
                playJumpSound();
            }
        }

        // Simple sound effect for jumping using Web Audio API
        function playJumpSound() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                // Set oscillator properties for a jump sound
                oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime); // C5
                oscillator.frequency.exponentialRampToValueAtTime(783.99, audioContext.currentTime + 0.1); // G5
                oscillator.type = 'square'; // Square wave for a classic sound
                
                gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2); // Fade out quickly
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.2);
            } catch (e) {
                console.warn('AudioContext not supported or error playing sound:', e);
            }
        }

        function enterWorld() {
            if (currentWorldZone) {
                const worldData = worlds[currentWorldZone];
                console.log(`Entering ${worldData.title}! Link: ${worldData.link}`);
                // In a real portfolio, you would redirect, open a modal, or load a new scene here.
                // Example: window.open(worldData.link, '_blank');
                // For now, let's just hide the info and log.
                document.getElementById('worldInfo').classList.remove('active');
                currentWorldZone = null; // Reset
                document.getElementById('enterBtn').style.display = 'none'; // Hide button
                updateCurrentWorldUI('×”××‘'); // Set world back to Hub
            }
        }

        function resetCamera() {
            // Reset mouse influence
            mouseX = 0;
            mouseY = 0;
            // Instantly snap camera back to initial position relative to Mario
            const initialOffset = new THREE.Vector3(0, 8, 12);
            const marioWorldPosition = new THREE.Vector3();
            mario.getWorldPosition(marioWorldPosition);
            
            camera.position.copy(marioWorldPosition.add(initialOffset));
            camera.lookAt(marioWorldPosition.sub(initialOffset)); // Look back at Mario's original spot
            camera.lookAt(mario.position); // Ensure it looks directly at Mario
        }

        // --- Game Logic Updates (per frame) ---
        function updateMario() {
            const delta = clock.getDelta(); // Time elapsed since last frame for consistent movement
            const speed = (keys['ShiftLeft'] || keys['ShiftRight']) ? 10 * delta : 5 * delta; // Faster with Shift

            // Apply friction to slow down Mario when no keys are pressed
            marioVelocity.x *= 0.8;
            marioVelocity.z *= 0.8;

            // Apply movement based on keys
            if (keys['KeyW'] || keys['ArrowUp']) {
                marioVelocity.z -= speed;
            }
            if (keys['KeyS'] || keys['ArrowDown']) {
                marioVelocity.z += speed;
            }
            if (keys['KeyA'] || keys['ArrowLeft']) {
                marioVelocity.x -= speed;
                mario.rotation.y = Math.PI / 2; // Rotate Mario to face left
            }
            if (keys['KeyD'] || keys['ArrowRight']) {
                marioVelocity.x += speed;
                mario.rotation.y = -Math.PI / 2; // Rotate Mario to face right
            }

            // Cap max speed to prevent excessive velocity
            const maxSpeed = 10 * delta;
            marioVelocity.x = Math.max(-maxSpeed, Math.min(maxSpeed, marioVelocity.x));
            marioVelocity.z = Math.max(-maxSpeed, Math.min(maxSpeed, marioVelocity.z));

            // Apply gravity
            marioVelocity.y -= 25 * delta; // Gravity constant multiplied by delta

            // Update Mario's position
            mario.position.x += marioVelocity.x;
            mario.position.y += marioVelocity.y;
            mario.position.z += marioVelocity.z;

            // Ground collision
            const groundY = 2; // Y position of the ground plane
            if (mario.position.y <= groundY) {
                mario.position.y = groundY;
                marioVelocity.y = 0;
                isGrounded = true;
            }

            // Simple collision for platforms (assuming platforms are the only objects Mario can stand on explicitly)
            // If mushroom buildings should also be standable, their collision logic needs to be added here.
            // For now, only the smaller platforms are considered for vertical collision.
            interactiveZones.forEach(zone => {
                if (zone.mesh.userData.type === 'platform') { // Only check platforms for vertical landing
                    const distance = mario.position.distanceTo(zone.mesh.position);
                    const collisionThreshold = 4; // Mario's radius + platform radius
                    const platformTopY = zone.mesh.position.y + 0.5; // Top surface of the platform

                    if (distance < collisionThreshold && mario.position.y >= platformTopY - 1 && marioVelocity.y <= 0) {
                        // If falling onto the platform
                        mario.position.y = platformTopY;
                        marioVelocity.y = 0;
                        isGrounded = true;
                    }
                }
            });

            // World boundaries (keep Mario within the ground plane)
            const worldBound = 45;
            mario.position.x = Math.max(-worldBound, Math.min(worldBound, mario.position.x));
            mario.position.z = Math.max(-worldBound, Math.min(worldBound, mario.position.z));
        }

        function updateCamera() {
            // Smoothly follow Mario from a fixed distance and angle
            const offset = new THREE.Vector3(0, 8, 12); // Camera offset from Mario
            
            // Get Mario's current world position
            const marioWorldPosition = new THREE.Vector3();
            mario.getWorldPosition(marioWorldPosition);
            
            // Adjust camera target position based on mouse input for looking around
            const targetX = marioWorldPosition.x + mouseX * 5;
            const targetY = marioWorldPosition.y + 8 + mouseY * 3;
            const targetZ = marioWorldPosition.z + 12;

            const targetPosition = new THREE.Vector3(targetX, targetY, targetZ);

            camera.position.lerp(targetPosition, 0.05); // Smooth interpolation
            camera.lookAt(mario.position); // Always look at Mario
        }

        // --- Interaction Logic ---
        function checkWorldProximity() {
            let nearestWorld = null;
            let minDistance = Infinity;
            const proximityThreshold = 8; // Distance to trigger world info

            interactiveZones.forEach(zone => { // Iterate over ALL interactive zones (platforms and mushroom buildings)
                const distance = mario.position.distanceTo(zone.mesh.position);
                if (distance < proximityThreshold && distance < minDistance) {
                    minDistance = distance;
                    nearestWorld = zone.worldKey;
                }
            });

            const worldInfoPanel = document.getElementById('worldInfo');
            const worldTitleElem = document.getElementById('worldTitle');
            const worldDescriptionElem = document.getElementById('worldDescription');
            const enterBtn = document.getElementById('enterBtn');

            if (nearestWorld && nearestWorld !== currentWorldZone) {
                // Mario entered a new world zone
                currentWorldZone = nearestWorld;
                const worldData = worlds[currentWorldZone];
                worldTitleElem.innerText = worldData.title;
                worldDescriptionElem.innerText = worldData.description;
                enterBtn.style.display = 'block'; // Show the enter button
                worldInfoPanel.classList.add('active'); // Show with animation
                // Update UI location to the world's primary name (e.g., "Web", "Animation")
                updateCurrentWorldUI(worldData.title.split(' ')[0]); 
            } else if (!nearestWorld && currentWorldZone) {
                // Mario left the current world zone
                currentWorldZone = null;
                worldInfoPanel.classList.remove('active'); // Hide with animation
                document.getElementById('enterBtn').style.display = 'none'; // Hide button
                worldTitleElem.innerText = "×‘×¨×•×š ×”×‘×!";
                worldDescriptionElem.innerText = "×”×ª×§×¨×‘ ×œ××—×ª ×”×¤×œ×˜×¤×•×¨××•×ª ××• ×œ××‘× ×™ ×”×¤×˜×¨×™×™×” ×›×“×™ ×œ×¨××•×ª ×¤×¨×˜×™× ×•×œ×”×™×›× ×¡ ×œ×¢×•×œ×!";
                updateCurrentWorldUI('×”××‘'); // Reset world name to Hub
            }
        }

        function checkCollectibleCollision() {
            const marioBoundingBox = new THREE.Box3().setFromObject(mario);

            collectibles.forEach(collectible => {
                if (collectible.parent === scene) { // Only check if still in scene
                    const collectibleBoundingBox = new THREE.Box3().setFromObject(collectible);
                    if (marioBoundingBox.intersectsBox(collectibleBoundingBox)) {
                        // Collision detected!
                        if (collectible.userData.type === 'coin') {
                            updateCoinCount(collectible.userData.value);
                            console.log('Collected Coin!');
                        } else if (collectible.userData.type === 'powerup') {
                            updateLives(collectible.userData.value);
                            console.log('Collected Power-Up!');
                        }
                        scene.remove(collectible); // Remove collectible from scene
                    }
                }
            });
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate); // Request next frame for continuous animation

            const delta = clock.getDelta(); // Get time elapsed since last frame

            // Update game logic
            updateMario();
            updateCamera();
            checkWorldProximity();
            checkCollectibleCollision();

            // Animate collectibles (spin and float)
            collectibles.forEach(collectible => {
                if (collectible.parent === scene) { // Only animate if still in scene
                    collectible.rotation.y += collectible.userData.rotationSpeed || 0.05; // Spin
                    // Simple bobbing motion
                    collectible.position.y = collectible.userData.originalY + Math.sin(clock.elapsedTime * 3) * 0.5;
                }
            });

            // Animate question blocks on platforms (bobbing)
            interactiveZones.forEach(zone => {
                // Assuming only platforms have question blocks for now
                if (zone.mesh.userData.type === 'platform') {
                    const questionBlock = zone.mesh.children.find(child => child.userData.isQuestionBlock);
                    if (questionBlock) {
                        questionBlock.position.y = questionBlock.userData.originalY + Math.sin(clock.elapsedTime * 5) * 0.1;
                    }
                }
            });

            // Animate clouds
            animatedClouds.forEach(cloud => {
                cloud.position.x += cloud.userData.speed * delta * 5; // Move horizontally
                // Reset cloud position if it goes out of bounds to create a continuous loop
                if (cloud.userData.speed > 0 && cloud.position.x > 120) {
                    cloud.position.x = -120 - Math.random() * 50; // Reset far left
                } else if (cloud.userData.speed < 0 && cloud.position.x < -120) {
                    cloud.position.x = 120 + Math.random() * 50; // Reset far right
                }
            });


            renderer.render(scene, camera); // Render the scene
        }

        // --- Entry Point ---
        window.onload = function () {
            // Initialize the game when the window loads
            init();
        };
    </script>
</body>
</html>
