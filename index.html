<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Fantasy Portfolio World</title>
  <style>
    body { 
      margin: 0; 
      overflow: hidden; 
      background: #1a1a2e;
      font-family: 'Arial', sans-serif;
    }
    canvas { display: block; }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-family: sans-serif;
      background: rgba(0,0,0,0.7);
      padding: 15px;
      border-radius: 12px;
      border: 2px solid #ff00ff;
      box-shadow: 0 0 20px rgba(255, 0, 255, 0.3);
      z-index: 100;
    }
    #loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 24px;
      z-index: 200;
    }
  </style>
</head>
<body>
  <div id="loading">Loading Fantasy World...</div>
  <div id="info" style="display: none;">
    Use arrow keys to move around the floating islands.<br>
    Approach a glowing portal to explore different portfolio sections.
  </div>

  <!-- Load Three.js from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <script>
    // Initialize scene
    let scene = new THREE.Scene();
    
    // Create starfield background
    const starsGeometry = new THREE.BufferGeometry();
    const starsMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 2 });
    
    const starsVertices = [];
    for (let i = 0; i < 10000; i++) {
      const x = (Math.random() - 0.5) * 2000;
      const y = (Math.random() - 0.5) * 2000;
      const z = (Math.random() - 0.5) * 2000;
      starsVertices.push(x, y, z);
    }
    
    starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
    const stars = new THREE.Points(starsGeometry, starsMaterial);
    scene.add(stars);
    
    // Set scene background color
    scene.background = new THREE.Color(0x0a0a1e);

    // Camera setup
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    
    // Renderer setup
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    // Lighting
    const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(50, 50, 50);
    directionalLight.castShadow = true;
    scene.add(directionalLight);

    // Floating islands function
    function createIsland(x, z, color = 0x445522) {
      const group = new THREE.Group();
      
      // Island base (inverted cone)
      const baseGeo = new THREE.ConeGeometry(4, 6, 8);
      const baseMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
      const base = new THREE.Mesh(baseGeo, baseMat);
      base.position.y = -3;
      base.rotation.x = Math.PI;
      group.add(base);

      // Island top (grass surface)
      const topGeo = new THREE.CylinderGeometry(4, 4, 1, 16);
      const topMat = new THREE.MeshLambertMaterial({ color: color });
      const top = new THREE.Mesh(topGeo, topMat);
      top.position.y = 0.5;
      group.add(top);
      
      // Add some decorative crystals
      for (let i = 0; i < 3; i++) {
        const crystal = new THREE.Mesh(
          new THREE.OctahedronGeometry(0.3),
          new THREE.MeshLambertMaterial({ 
            color: Math.random() * 0xffffff,
            transparent: true,
            opacity: 0.8
          })
        );
        crystal.position.set(
          (Math.random() - 0.5) * 6,
          1.5,
          (Math.random() - 0.5) * 6
        );
        group.add(crystal);
      }
      
      group.position.set(x, 0, z);
      scene.add(group);
      
      return group;
    }

    // Create islands
    const islands = [
      createIsland(15, -15, 0x4CAF50),
      createIsland(-15, -15, 0x2196F3),
      createIsland(-15, 15, 0xFF9800),
      createIsland(15, 15, 0x9C27B0)
    ];

    // Character (simple geometric representation)
    let character;
    function createCharacter() {
      const group = new THREE.Group();
      
      // Body
      const body = new THREE.Mesh(
        new THREE.CapsuleGeometry(0.5, 1.5, 4, 8),
        new THREE.MeshLambertMaterial({ color: 0x4FC3F7 })
      );
      body.position.y = 1;
      group.add(body);
      
      // Head
      const head = new THREE.Mesh(
        new THREE.SphereGeometry(0.4, 8, 8),
        new THREE.MeshLambertMaterial({ color: 0xFFD54F })
      );
      head.position.y = 2.2;
      group.add(head);
      
      // Simple face
      const eye1 = new THREE.Mesh(
        new THREE.SphereGeometry(0.05),
        new THREE.MeshBasicMaterial({ color: 0x000000 })
      );
      eye1.position.set(-0.15, 2.3, 0.35);
      group.add(eye1);
      
      const eye2 = new THREE.Mesh(
        new THREE.SphereGeometry(0.05),
        new THREE.MeshBasicMaterial({ color: 0x000000 })
      );
      eye2.position.set(0.15, 2.3, 0.35);
      group.add(eye2);
      
      group.position.set(0, 2, 0);
      return group;
    }

    character = createCharacter();
    scene.add(character);

    // Portal data
    const portals = [
      { name: "Web Development", position: [15, 3, -15], color: 0x00ff88, link: "web-dev.html" },
      { name: "Graphic Design", position: [-15, 3, -15], color: 0xff4444, link: "design.html" },
      { name: "AI Projects", position: [-15, 3, 15], color: 0x4444ff, link: "ai.html" },
      { name: "Animations", position: [15, 3, 15], color: 0xffaa00, link: "animation.html" }
    ];

    // Create portals
    const portalMeshes = [];
    portals.forEach(({ name, position, color, link }) => {
      const group = new THREE.Group();
      
      // Outer ring
      const outerRing = new THREE.Mesh(
        new THREE.TorusGeometry(2, 0.2, 16, 100),
        new THREE.MeshBasicMaterial({ 
          color: color,
          transparent: true,
          opacity: 0.8
        })
      );
      outerRing.rotation.x = Math.PI / 2;
      group.add(outerRing);
      
      // Inner ring
      const innerRing = new THREE.Mesh(
        new THREE.TorusGeometry(1.5, 0.1, 16, 100),
        new THREE.MeshBasicMaterial({ 
          color: 0xffffff,
          transparent: true,
          opacity: 0.6
        })
      );
      innerRing.rotation.x = Math.PI / 2;
      group.add(innerRing);
      
      // Portal center effect
      const center = new THREE.Mesh(
        new THREE.CircleGeometry(1.3, 32),
        new THREE.MeshBasicMaterial({ 
          color: color,
          transparent: true,
          opacity: 0.3
        })
      );
      center.rotation.x = -Math.PI / 2;
      group.add(center);
      
      group.position.set(...position);
      group.userData = { name, link, triggered: false };
      scene.add(group);
      portalMeshes.push(group);
    });

    // Create floating text labels
    function createTextLabel(text, position, color = 0xffffff) {
      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');
      canvas.width = 512;
      canvas.height = 128;
      
      context.fillStyle = 'rgba(0,0,0,0.8)';
      context.fillRect(0, 0, canvas.width, canvas.height);
      
      context.fillStyle = `rgb(${(color >> 16) & 255}, ${(color >> 8) & 255}, ${color & 255})`;
      context.font = 'bold 36px Arial';
      context.textAlign = 'center';
      context.fillText(text, canvas.width / 2, canvas.height / 2 + 12);
      
      const texture = new THREE.CanvasTexture(canvas);
      const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
      const sprite = new THREE.Sprite(material);
      sprite.position.set(...position);
      sprite.scale.set(8, 2, 1);
      
      return sprite;
    }

    // Add text labels for portals
    portals.forEach(({ name, position, color }) => {
      const label = createTextLabel(name, [position[0], position[1] + 3, position[2]], color);
      scene.add(label);
    });

    // Camera setup
    camera.position.set(0, 8, 12);
    camera.lookAt(0, 0, 0);

    // Controls
    const keys = {};
    document.addEventListener('keydown', (e) => keys[e.code] = true);
    document.addEventListener('keyup', (e) => keys[e.code] = false);

    // Animation variables
    let time = 0;
    const triggered = new Set();

    // Hide loading and show info
    setTimeout(() => {
      document.getElementById('loading').style.display = 'none';
      document.getElementById('info').style.display = 'block';
    }, 1000);

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      time += 0.016;

      // Rotate stars
      stars.rotation.y += 0.0005;
      
      // Animate portals
      portalMeshes.forEach((portal, index) => {
        portal.rotation.z += 0.02;
        portal.children[0].rotation.z += 0.01;
        
        // Floating animation
        portal.position.y = portals[index].position[1] + Math.sin(time * 2 + index) * 0.3;
      });

      // Character movement
      if (character) {
        const speed = 0.15;
        let moved = false;
        
        if (keys['ArrowUp'] || keys['KeyW']) {
          character.position.z -= speed;
          moved = true;
        }
        if (keys['ArrowDown'] || keys['KeyS']) {
          character.position.z += speed;
          moved = true;
        }
        if (keys['ArrowLeft'] || keys['KeyA']) {
          character.position.x -= speed;
          moved = true;
        }
        if (keys['ArrowRight'] || keys['KeyD']) {
          character.position.x += speed;
          moved = true;
        }
        
        // Simple walking animation
        if (moved) {
          character.rotation.y = Math.sin(time * 10) * 0.1;
          character.children[0].rotation.x = Math.sin(time * 8) * 0.1;
        }

        // Check portal proximity
        portalMeshes.forEach(portal => {
          if (!portal.userData.triggered) {
            const distance = character.position.distanceTo(portal.position);
            if (distance < 3) {
              portal.userData.triggered = true;
              
              // Create visual feedback
              portal.scale.set(1.2, 1.2, 1.2);
              
              // Show message
              document.getElementById('info').innerHTML = `
                Entering ${portal.userData.name}...<br>
                <small>In a real implementation, this would navigate to ${portal.userData.link}</small>
              `;
              
              // In a real implementation, you would navigate:
              // window.location.href = portal.userData.link;
              
              // Reset after delay
              setTimeout(() => {
                portal.userData.triggered = false;
                portal.scale.set(1, 1, 1);
                document.getElementById('info').innerHTML = `
                  Use arrow keys to move around the floating islands.<br>
                  Approach a glowing portal to explore different portfolio sections.
                `;
              }, 3000);
            }
          }
        });

        // Update camera to follow character
        camera.position.x = character.position.x + Math.sin(time * 0.5) * 2;
        camera.position.z = character.position.z + 12 + Math.cos(time * 0.3) * 1;
        camera.lookAt(character.position.x, character.position.y, character.position.z);
      }

      renderer.render(scene, camera);
    }

    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Start animation
    animate();
  </script>
</body>
</html>
